//
//  DownloadFileHelper.swift
//  iOStarter
//
//  Created by Macintosh on 07/04/22.
//  
//
//  This file was generated by Project Xcode Templates
//  Created by Wahyu Ady Prasetyo,
//  Source: https://github.com/dypme/iOStarter
//

import Foundation
import UIKit
import Alamofire

/// File document that will search or use to save downloaded file
fileprivate let savedDirectory = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0]

extension URL {
    fileprivate var fileNameFormat: String {
        self.lastPathComponent.removingPercentEncoding?.replacingOccurrences(of: " ", with: "_") ?? ""
    }
}

class DirectoryHelper {
    /// Durectory of files
    private static var directory: URL {
        let directory = savedDirectory as String
        let dirUrl    = URL(fileURLWithPath: directory)
        return dirUrl
    }
    
    /// Get file from name of file
    ///
    /// - Parameter name: Name of file
    /// - Returns: File data and file url
    static func file(name: String) -> (data: Data?, url: String) {
        let fileUrl  = directory.appendingPathComponent(name)
        
        let fileManager = FileManager.default
        if fileManager.fileExists(atPath: fileUrl.path) {
            do {
                let file = try Data(contentsOf: fileUrl)
                return (file, fileUrl.absoluteString)
            } catch {
                return (nil, "File not found in directory")
            }
        } else {
            return (nil, "File not found in directory")
        }
    }
    
    /// Get file in directory
    ///
    /// - Parameter url: url of file
    /// - Returns: File data and full file path
    static func file(from url: URL) -> (data: Data?, url: String) {
        file(name: url.fileNameFormat)
    }
}

class DownloadHelper {
    static var queue: [(url: URL, data: Data?)] = []
    
    /// Data for resuming paused download data
    private var resumeData: Data?
    /// Result of download data
    private var downloadData: Data?
    
    /// Url to download with regenerate to valid download url
    private var downloadUrl: URL? {
        if let url = url, UIApplication.shared.canOpenURL(url) {
            return url
        }
        let urlPercentEncoding = url?.absoluteString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? ""
        return URL(string: urlPercentEncoding)
    }
    /// Original url to download
    private var url: URL?
    private var isForceDownload: Bool
    
    /// Initialize download url
    ///
    /// - Parameter url: File url will be download
    init(url: URL?, forceDownload: Bool = false) {
        self.url = url
        self.isForceDownload = forceDownload
    }
    
    /// Initialize url from string type data
    ///
    /// - Parameter string: File url will be download
    init(url string: String, forceDownload: Bool = false) {
        url = URL(string: string)
        self.isForceDownload = forceDownload
    }
    
    /// Starting download file
    ///
    /// - Parameters:
    ///   - progress: Download progress closure
    ///   - completion: Complete download progress closure
    func fetch(progress: ((Progress) -> Void)? = nil, completion: @escaping ((Data?, String) -> Void)) {
        guard let downloadUrl = self.downloadUrl else {
            completion(nil, "")
            return
        }
        
        // Receive from local file
        let localFile = DirectoryHelper.file(from: downloadUrl)
        let isFileLocalExist = localFile.data != nil || downloadData != nil
        if isFileLocalExist && !isForceDownload  {
            completion(localFile.data, localFile.url)
            return
        }
        
        let destination: DownloadRequest.Destination = { _, _ in
            let documentsURL = URL(fileURLWithPath: savedDirectory)
            let fileName = downloadUrl.fileNameFormat
            let fileURL = documentsURL.appendingPathComponent(fileName)
            return (fileURL, [.removePreviousFile, .createIntermediateDirectories])
        }
        
        let request: DownloadRequest?
        if let data = DownloadHelper.queue.first(where: { $0.url == downloadUrl }) {
            self.resumeData = data.data
        } else {
            DownloadHelper.queue.append((downloadUrl, self.resumeData))
        }
        let session = ApiHelper.shared.afManager
        if let resumeData = resumeData {
            request = session?.download(resumingWith: resumeData, to: destination).downloadProgress { (progressDownload) in
                progress?(progressDownload)
            }
        } else {
            request = session?.download(downloadUrl, to: destination).downloadProgress { (progressDownload) in
                progress?(progressDownload)
            }
        }
        
        request?.responseData { response in
            switch response.result {
            case .success(let data):
                self.downloadData = data
                
                if let index = DownloadHelper.queue.firstIndex(where: { $0.url == downloadUrl }) {
                    DownloadHelper.queue.remove(at: index)
                }
                
                let localFile = DirectoryHelper.file(from: downloadUrl)
                completion(localFile.data, localFile.url)
            case .failure:
                self.resumeData = response.resumeData
                
                if let index = DownloadHelper.queue.firstIndex(where: { $0.url == downloadUrl }) {
                    DownloadHelper.queue[index].data = self.resumeData
                }
            }
        }
    }
}
