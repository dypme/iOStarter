//
//  DownloadFileHelper.swift
//  iOStarter
//
//  Created by Macintosh on 07/04/22.
//  
//
//  This file was generated by Project Xcode Templates
//  Created by Wahyu Ady Prasetyo,
//  Source: https://github.com/dypme/iOStarter
//

import Foundation
import UIKit
import Alamofire

/// File document that will search or use to save downloaded file
fileprivate let savedDirectory = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0]

extension URL {
    fileprivate var fileNameFormat: String {
        self.lastPathComponent.removingPercentEncoding?.replacingOccurrences(of: " ", with: "_") ?? ""
    }
}

struct File {
    let data: Data?
    let path: String
}

class DirectoryHelper {
    /// Durectory of files
    private static var directory: URL {
        let directory = savedDirectory as String
        let dirUrl    = URL(fileURLWithPath: directory)
        return dirUrl
    }
    
    /// Get file from name of file
    ///
    /// - Parameter name: Name of file
    /// - Returns: File data and file url
    static func file(name: String) -> File? {
        let fileUrl  = directory.appendingPathComponent(name)
        
        let fileManager = FileManager.default
        if fileManager.fileExists(atPath: fileUrl.path) {
            do {
                let file = try Data(contentsOf: fileUrl)
                return File(data: file, path: fileUrl.absoluteString)
            } catch {
                return nil
            }
        } else {
            return nil
        }
    }
    
    /// Get file in directory
    ///
    /// - Parameter url: url of file
    /// - Returns: File data and full file path
    static func file(from url: URL) -> File? {
        return file(name: url.fileNameFormat)
    }
}

class DownloadManager {
    static var queue: [(url: URL, data: Data?)] = []
    
    /// Data for resuming paused download data
    private var downloadedData: Data?
    
    /// Url to download with regenerate to valid download url
    private var downloadUrl: URL? {
        if let url = url, UIApplication.shared.canOpenURL(url) {
            return url
        }
        let urlPercentEncoding = url?.absoluteString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? ""
        return URL(string: urlPercentEncoding)
    }
    /// Original url to download
    private var url: URL?
    private var isForceDownload: Bool
    
    /// Initialize download url
    ///
    /// - Parameter url: File url will be download
    init(url: URL?, forceDownload: Bool = false) {
        self.url = url
        self.isForceDownload = forceDownload
    }
    
    /// Initialize url from string type data
    ///
    /// - Parameter string: File url will be download
    init(url string: String, forceDownload: Bool = false) {
        url = URL(string: string)
        self.isForceDownload = forceDownload
    }
    
    /// Starting download file
    ///
    /// - Parameters:
    ///   - progress: Download progress closure
    ///   - completion: Complete download progress closure
    func fetch(progress: ((Progress) -> Void)? = nil) async -> File? {
        guard let downloadUrl = self.downloadUrl else {
            return nil
        }
        
        // Receive from local file
        if let localFile = DirectoryHelper.file(from: downloadUrl), let data = localFile.data, !isForceDownload {
            return File(data: data, path: localFile.path)
        }
        
        let destination: DownloadRequest.Destination = { _, _ in
            let documentsURL = URL(fileURLWithPath: savedDirectory)
            let fileName = downloadUrl.fileNameFormat
            let fileURL = documentsURL.appendingPathComponent(fileName)
            return (fileURL, [.removePreviousFile, .createIntermediateDirectories])
        }
        
        if let data = DownloadManager.queue.first(where: { $0.url == downloadUrl }) {
            self.downloadedData = data.data
        } else {
            DownloadManager.queue.append((downloadUrl, self.downloadedData))
        }
        
        let request: DownloadRequest
        let session = ApiManager.shared.sessionManager
        if let downloadedData = downloadedData {
            request = session.download(resumingWith: downloadedData, to: destination)
        } else {
            request = session.download(downloadUrl, to: destination)
        }
        request.downloadProgress(closure: { progress?($0) })
        
        let downloadTask = request.serializingData()
        do {
            let data = try await downloadTask.value
            if let index = DownloadManager.queue.firstIndex(where: { $0.url == downloadUrl }) {
                DownloadManager.queue.remove(at: index)
            }
            
            let localFile = DirectoryHelper.file(from: downloadUrl)
            return localFile
        } catch {
            return nil
        }
    }
}
